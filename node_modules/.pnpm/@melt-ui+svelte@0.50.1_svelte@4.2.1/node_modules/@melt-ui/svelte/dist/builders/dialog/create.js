import { createFocusTrap, useClickOutside, useEscapeKeydown, usePortal, } from '../../internal/actions/index.js';
import { addMeltEventListener, builder, createElHelpers, effect, executeCallbacks, generateId, getPortalDestination, isBrowser, isHTMLElement, kbd, last, noop, overridable, removeScroll, sleep, styleToString, toWritableStores, } from '../../internal/helpers/index.js';
import { onMount, tick } from 'svelte';
import { derived, get, writable } from 'svelte/store';
const { name } = createElHelpers('dialog');
const defaults = {
    preventScroll: true,
    closeOnEscape: true,
    closeOnOutsideClick: true,
    role: 'dialog',
    defaultOpen: false,
    portal: 'body',
    forceVisible: false,
};
const openDialogIds = writable([]);
export function createDialog(props) {
    const withDefaults = { ...defaults, ...props };
    const options = toWritableStores(withDefaults);
    const { preventScroll, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible } = options;
    const activeTrigger = writable(null);
    const ids = {
        content: generateId(),
        title: generateId(),
        description: generateId(),
        trigger: generateId(),
    };
    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
    const open = overridable(openWritable, withDefaults?.onOpenChange);
    const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
        return $open || $forceVisible;
    });
    function handleOpen(e) {
        const el = e.currentTarget;
        const triggerEl = e.currentTarget;
        if (!isHTMLElement(el) || !isHTMLElement(triggerEl))
            return;
        open.set(true);
        activeTrigger.set(triggerEl);
    }
    function handleClose() {
        open.set(false);
        const triggerEl = document.getElementById(ids.trigger);
        if (triggerEl) {
            tick().then(() => {
                triggerEl.focus();
            });
        }
    }
    onMount(() => {
        activeTrigger.set(document.getElementById(ids.trigger));
    });
    effect([open], ([$open]) => {
        // Prevent double clicks from closing multiple dialogs
        sleep(100).then(() => {
            if ($open) {
                openDialogIds.update((prev) => {
                    prev.push(ids.content);
                    return prev;
                });
            }
            else {
                openDialogIds.update((prev) => prev.filter((id) => id !== ids.content));
            }
        });
    });
    const trigger = builder(name('trigger'), {
        stores: open,
        returned: ($open) => {
            return {
                id: ids.trigger,
                'aria-haspopup': 'dialog',
                'aria-expanded': $open,
                'aria-controls': ids.content,
                type: 'button',
            };
        },
        action: (node) => {
            const unsub = executeCallbacks(addMeltEventListener(node, 'click', (e) => {
                handleOpen(e);
            }), addMeltEventListener(node, 'keydown', (e) => {
                if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
                    return;
                e.preventDefault();
                handleOpen(e);
            }));
            return {
                destroy: unsub,
            };
        },
    });
    const overlay = builder(name('overlay'), {
        stores: [isVisible],
        returned: ([$isVisible]) => {
            return {
                hidden: $isVisible ? undefined : true,
                tabindex: -1,
                style: styleToString({
                    display: $isVisible ? undefined : 'none',
                }),
                'aria-hidden': true,
                'data-state': $isVisible ? 'open' : 'closed',
            };
        },
        action: (node) => {
            let unsubEscapeKeydown = noop;
            if (get(closeOnEscape)) {
                const escapeKeydown = useEscapeKeydown(node, {
                    handler: () => {
                        handleClose();
                    },
                });
                if (escapeKeydown && escapeKeydown.destroy) {
                    unsubEscapeKeydown = escapeKeydown.destroy;
                }
            }
            return {
                destroy() {
                    unsubEscapeKeydown();
                },
            };
        },
    });
    const content = builder(name('content'), {
        stores: [isVisible],
        returned: ([$isVisible]) => {
            return {
                id: ids.content,
                role: get(role),
                'aria-describedby': ids.description,
                'aria-labelledby': ids.title,
                'data-state': $isVisible ? 'open' : 'closed',
                tabindex: -1,
                hidden: $isVisible ? undefined : true,
                style: styleToString({
                    display: $isVisible ? undefined : 'none',
                }),
            };
        },
        action: (node) => {
            let activate = noop;
            let deactivate = noop;
            const destroy = executeCallbacks(effect([open], ([$open]) => {
                if (!$open)
                    return;
                const focusTrap = createFocusTrap({
                    immediate: false,
                    escapeDeactivates: false,
                    returnFocusOnDeactivate: false,
                    fallbackFocus: node,
                });
                activate = focusTrap.activate;
                deactivate = focusTrap.deactivate;
                const ac = focusTrap.useFocusTrap(node);
                if (ac && ac.destroy) {
                    return ac.destroy;
                }
                else {
                    return focusTrap.deactivate;
                }
            }), effect([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {
                return useClickOutside(node, {
                    enabled: $open,
                    handler: (e) => {
                        if (e.defaultPrevented)
                            return;
                        const $openDialogIds = get(openDialogIds);
                        const isLast = last($openDialogIds) === ids.content;
                        if ($closeOnOutsideClick && isLast) {
                            handleClose();
                        }
                    },
                }).destroy;
            }), effect([closeOnEscape], ([$closeOnEscape]) => {
                if (!$closeOnEscape)
                    return noop;
                const escapeKeydown = useEscapeKeydown(node, {
                    handler: () => {
                        handleClose();
                    },
                });
                if (escapeKeydown && escapeKeydown.destroy) {
                    return escapeKeydown.destroy;
                }
                return noop;
            }), effect([isVisible], ([$isVisible]) => {
                tick().then(() => {
                    if (!$isVisible) {
                        deactivate();
                    }
                    else {
                        activate();
                    }
                });
            }));
            return {
                destroy,
            };
        },
    });
    const portalled = builder(name('portalled'), {
        stores: portal,
        returned: ($portal) => ({
            'data-portal': $portal ? '' : undefined,
        }),
        action: (node) => {
            const unsubPortal = effect([portal], ([$portal]) => {
                if (!$portal)
                    return noop;
                const portalDestination = getPortalDestination(node, $portal);
                if (portalDestination === null)
                    return noop;
                const portalAction = usePortal(node, portalDestination);
                if (portalAction && portalAction.destroy) {
                    return portalAction.destroy;
                }
                else {
                    return noop;
                }
            });
            return {
                destroy() {
                    unsubPortal();
                },
            };
        },
    });
    const title = builder(name('title'), {
        returned: () => ({
            id: ids.title,
        }),
    });
    const description = builder(name('description'), {
        returned: () => ({
            id: ids.description,
        }),
    });
    const close = builder(name('close'), {
        returned: () => ({
            type: 'button',
        }),
        action: (node) => {
            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {
                handleClose();
            }), addMeltEventListener(node, 'keydown', (e) => {
                if (e.key !== kbd.SPACE && e.key !== kbd.ENTER)
                    return;
                e.preventDefault();
                handleClose();
            }));
            return {
                destroy: unsub,
            };
        },
    });
    effect([open, preventScroll], ([$open, $preventScroll]) => {
        if (!isBrowser)
            return;
        const unsubs = [];
        if ($preventScroll && $open)
            unsubs.push(removeScroll());
        return () => {
            unsubs.forEach((unsub) => unsub());
        };
    });
    return {
        elements: {
            content,
            trigger,
            title,
            description,
            overlay,
            close,
            portalled,
        },
        states: {
            open,
        },
        options,
    };
}
